<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ART-CORE RECORDER</title>
    <style>
        /* --- UI 风格保持不变 (Comic Sans, 搞怪背景) --- */
        body {
            font-family: 'Comic Sans MS', 'Marker Felt', sans-serif;
            margin: 0; height: 100vh; overflow: hidden;
            background: repeating-linear-gradient(45deg, #333, #333 20px, #555 20px, #555 40px); /* 改成更忧郁的深色背景 */
            display: flex; flex-direction: column; align-items: center; justify-content: center; color: #eee;
        }
        .window-frame {
            background: #a83232; /* 锈红色边框 */
            border: 4px solid #000; width: 90%; max-width: 400px;
            box-shadow: 15px 15px 0 rgba(0,0,0,0.8); transform: rotate(-1deg);
            position: relative; padding-bottom: 20px;
        }
        .title-bar {
            background: #000; color: #f0e68c; padding: 5px; font-weight: bold; display: flex; justify-content: space-between; text-transform: uppercase; font-size: 12px; letter-spacing: 1px;
        }
        .marquee-container {
            background: #f0e68c; border-bottom: 4px solid #000; color: #000; font-weight: bold; padding: 2px 0; font-size: 12px;
        }
        .viewport-wrapper { padding: 15px; position: relative; }
        
        /* 关键修改：Viewport 容器 */
        .viewport {
            width: 100%; aspect-ratio: 3/4; background: #000; border: 4px solid #000; position: relative;
            /* 整体柔焦效果 */
            filter: blur(0.5px) contrast(1.1) saturate(1.2);
            overflow: hidden;
        }

        canvas { 
            width: 100%; height: 100%; display: block;
            /* 稍微放大一点画布，制造边缘不整齐的感觉 */
            transform: scale(1.02);
        }

        /* 贴纸装饰 */
        .sticker { position: absolute; pointer-events: none; z-index: 20; filter: drop-shadow(3px 3px 0 #000); }
        .s-tape { top: -10px; left: 30%; background: #d0c0a0; width: 40%; height: 20px; transform: rotate(2deg); opacity: 0.9; }
        .s-rec { top: 10px; left: -15px; background: #ff0000; color: white; padding: 4px 8px; font-weight: bold; border: 2px solid black; transform: rotate(-15deg); display: none; font-size: 14px; }
        .blinking { animation: blink 0.8s steps(1) infinite; }
        @keyframes blink { 50% {opacity: 0;} }

        .controls { display: flex; justify-content: center; gap: 15px; margin-top: 15px; }
        button {
            border: 3px solid #000; font-family: inherit; font-weight: 900; font-size: 18px; cursor: pointer; box-shadow: 6px 6px 0 #000; transition: transform 0.1s; text-transform: uppercase;
        }
        button:active { transform: translate(4px, 4px); box-shadow: 2px 2px 0 #000; }
        #recordBtn {
            background: #f0e68c; color: #000; padding: 15px 25px; transform: rotate(1deg); border-radius: 4px;
        }
        #recordBtn.recording {
            background: #ff4444; color: #fff;
        }
    </style>
</head>
<body>

    <div class="window-frame">
        <div class="title-bar">
            <span>SILKSCREEN_ILLUSTRATOR.exe</span>
            <span>[_]</span>
        </div>
        
        <div class="marquee-container">
            <marquee scrollamount="8">/// ANALOG VIBES // VINTAGE MAGAZINE HALFTONE // MOEBIUS MEETS BRATBY // 忧郁的色彩 // 80S PRINTING ERROR ///</marquee>
        </div>

        <div class="viewport-wrapper">
            <div class="sticker s-tape"></div>
            <div id="recIndicator" class="sticker s-rec blinking">● REC</div>
            <div class="viewport">
                <canvas id="displayCanvas"></canvas>
            </div>
        </div>

        <div class="controls">
            <button id="recordBtn">START PRINTING</button>
        </div>
    </div>

    <video id="rawVideo" autoplay playsinline muted style="display:none;"></video>

    <script>
        const video = document.getElementById('rawVideo');
        const canvas = document.getElementById('displayCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true }); // 优化读取性能
        const recordBtn = document.getElementById('recordBtn');
        const recIndicator = document.getElementById('recIndicator');

        // 分辨率设置：保持适中，太低了网点效果不好看
        const w = 240; 
        const h = 320; 
        canvas.width = w;
        canvas.height = h;

        let isStreaming = false;
        let mediaRecorder;
        let recordedChunks = [];
        let isRecording = false;

        // --- 核心：新的艺术渲染引擎 ---

        // 1. 定义“忧郁而大胆”的艺术色盘
        // 放弃了纯波普色，采用了更厚重、更有插画感的颜色
        const artPalette = [
            [20, 25, 40],    // 深墨蓝 (代替黑色，更丰富)
            [160, 50, 60],   // 锈红/砖红 (大胆的形状色)
            [210, 180, 80],  // 土黄/姜黄 (用于高光和剪影)
            [60, 100, 110],  // 灰蓝/青色 (忧郁的背景色)
            [220, 215, 190]  // 米白/旧纸张色 (极亮部)
        ];

        // 2. 预生成纹理图案 (为了性能，不能在循环里生成)
        
        // 创建半色调网点 (Halftone Pattern)
        const halftoneCanvas = document.createElement('canvas');
        halftoneCanvas.width = 8; halftoneCanvas.height = 8;
        const hCtx = halftoneCanvas.getContext('2d');
        hCtx.fillStyle = '#000';
        // 画一个圆点
        hCtx.beginPath(); hCtx.arc(4, 4, 3, 0, Math.PI * 2); hCtx.fill();
        const halftonePattern = ctx.createPattern(halftoneCanvas, 'repeat');

        // 创建颗粒噪点 (Grain Pattern)
        const noiseCanvas = document.createElement('canvas');
        noiseCanvas.width = 64; noiseCanvas.height = 64;
        const nCtx = noiseCanvas.getContext('2d');
        for (let i = 0; i < 2000; i++) {
            nCtx.fillStyle = `rgba(0,0,0,${Math.random() * 0.2})`; // 半透明黑点
            nCtx.fillRect(Math.random()*64, Math.random()*64, 1, 1);
            nCtx.fillStyle = `rgba(255,255,255,${Math.random() * 0.15})`; // 半透明白点
            nCtx.fillRect(Math.random()*64, Math.random()*64, 1, 1);
        }
        const noisePattern = ctx.createPattern(noiseCanvas, 'repeat');


        function colorDistSq(c1, c2) {
            // 加重对亮度差异的感知
            return (c1[0]-c2[0])**2*0.8 + (c1[1]-c2[1])**2*1.2 + (c1[2]-c2[2])**2*0.9;
        }

        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: "environment", width: {ideal: 640}, height: {ideal: 480} },
                    audio: true
                });
                video.srcObject = stream;
                video.onloadedmetadata = () => { isStreaming = true; renderFrame(); };
            } catch (err) { alert("需要摄像头和麦克风权限。"); }
        }

        function renderFrame() {
            if (!isStreaming) return;
            
            // A. 绘制原始视频并进行极端的对比度处理
            ctx.filter = 'contrast(2.0) saturate(1.5) brightness(0.9)'; // 高对比，高饱和，稍暗
            ctx.drawImage(video, 0, 0, w, h);
            ctx.filter = 'none'; // 重置滤镜

            // B. 获取像素数据进行色彩量化 (平涂阴影效果)
            let imgData = ctx.getImageData(0, 0, w, h);
            let data = imgData.data;

            for (let i = 0; i < data.length; i += 4) {
                let curR = data[i], curG = data[i+1], curB = data[i+2];
                // 简单的抖动，增加一点随机性，避免色块过于死板
                curR += (Math.random()-0.5)*15;
                curG += (Math.random()-0.5)*15;
                curB += (Math.random()-0.5)*15;

                let closest = artPalette[0]; let minD = Infinity;
                for (let col of artPalette) {
                    let d = colorDistSq([curR, curG, curB], col);
                    if (d < minD) { minD = d; closest = col; }
                }
                data[i] = closest[0]; data[i+1] = closest[1]; data[i+2] = closest[2];
                // data[i+3] (Alpha) 保持不变
            }
            ctx.putImageData(imgData, 0, 0);

            // C. 绘制纹理叠加层 (关键步骤：把纹理画死在画布上)

            // 1. 叠加半色调网点层 (Overlay 模式)
            ctx.globalCompositeOperation = 'overlay';
            ctx.fillStyle = halftonePattern;
            // 稍微错位一点，模拟印刷对不准
            ctx.translate(1, 1); 
            ctx.fillRect(-1, -1, w+2, h+2);
            ctx.translate(-1, -1);

            // 2. 叠加颗粒噪点层 (Multiply 模式，增加脏感)
            ctx.globalCompositeOperation = 'multiply';
            ctx.fillStyle = noisePattern;
            ctx.globalAlpha = 0.6; // 噪点强度
            ctx.fillRect(0, 0, w, h);
            ctx.globalAlpha = 1.0;
            
            // 重置混合模式
            ctx.globalCompositeOperation = 'source-over';

            requestAnimationFrame(renderFrame);
        }

        // --- 录像逻辑 (保持不变) ---
        function startRecording() {
            recordedChunks = [];
            // 捕捉画布流 (30FPS)
            const canvasStream = canvas.captureStream(30);
            if (video.srcObject && video.srcObject.getAudioTracks().length > 0) {
                canvasStream.addTrack(video.srcObject.getAudioTracks()[0]);
            }
            let options = { mimeType: 'video/webm;codecs=vp9' };
            if (!MediaRecorder.isTypeSupported(options.mimeType)) options = { mimeType: 'video/webm' };
            
            try {
                mediaRecorder = new MediaRecorder(canvasStream, options);
            } catch(e) { alert('录制初始化失败'); return; }

            mediaRecorder.ondataavailable = (event) => { if (event.data.size > 0) recordedChunks.push(event.data); };
            mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none'; a.href = url; a.download = 'SILKSCREEN-TAPE-' + Date.now() + '.webm';
                document.body.appendChild(a); a.click();
                setTimeout(() => { document.body.removeChild(a); window.URL.revokeObjectURL(url); }, 100);
            };
            mediaRecorder.start();
            isRecording = true; updateUIState(true);
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
            isRecording = false; updateUIState(false);
        }

        function updateUIState(recording) {
            if (recording) {
                recordBtn.innerText = "STOP PRINTING"; recordBtn.classList.add('recording'); recIndicator.style.display = "block";
            } else {
                recordBtn.innerText = "START PRINTING"; recordBtn.classList.remove('recording'); recIndicator.style.display = "none";
            }
        }

        recordBtn.addEventListener('click', () => {
            if (!isStreaming) return;
            if (!isRecording) startRecording(); else stopRecording();
        });

        startCamera();
    </script>
</body>
</html>
