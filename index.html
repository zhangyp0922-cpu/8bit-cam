<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TRASH RECORDER</title>
    <style>
        /* ä¿æŒåŸæœ‰çš„ææ€ª CSS ä¸å˜ */
        body {
            font-family: 'Comic Sans MS', 'Chalkboard SE', 'Marker Felt', sans-serif;
            margin: 0;
            height: 100vh;
            overflow: hidden;
            background: repeating-linear-gradient(45deg, #f2ff00, #f2ff00 20px, #000000 20px, #000000 40px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .window-frame {
            background: #ff00ff;
            border: 4px solid #000;
            width: 90%; max-width: 400px;
            box-shadow: 15px 15px 0 rgba(0,0,0,0.8);
            transform: rotate(-2deg);
            position: relative;
            padding-bottom: 20px;
        }
        .title-bar {
            background: #000; color: #fff; padding: 5px; font-weight: bold; display: flex; justify-content: space-between; text-transform: uppercase; font-size: 14px;
        }
        .marquee-container {
            background: #fff; border-bottom: 4px solid #000; color: #0000ff; font-weight: bold; padding: 2px 0; font-size: 12px;
        }
        .viewport-wrapper { padding: 15px; position: relative; }
        .viewport {
            width: 100%; aspect-ratio: 3/4; background: #000; border: 4px solid #000; position: relative; animation: shake 5s infinite;
        }
        canvas { width: 100%; height: 100%; image-rendering: pixelated; display: block; }
        .sticker { position: absolute; pointer-events: none; z-index: 10; filter: drop-shadow(3px 3px 0 #000); }
        .s-tape { top: -10px; left: 30%; background: #ddd; width: 40%; height: 20px; transform: rotate(2deg); opacity: 0.8; }
        .s-eye { bottom: -15px; right: -10px; font-size: 40px; transform: rotate(-20deg); }
        /* æŠŠ WOW è´´çº¸æ”¹æˆ REC æŒ‡ç¤ºç¯ */
        .s-rec { top: 10px; left: -15px; background: red; color: white; padding: 2px 5px; font-weight: bold; border: 2px solid black; transform: rotate(-15deg); display: none; }
        /* å½•åˆ¶æ—¶é—ªçƒåŠ¨ç”» */
        .blinking { animation: blink 1s infinite; }
        @keyframes blink { 0% {opacity: 1;} 50% {opacity: 0.4;} 100% {opacity: 1;} }

        .controls { display: flex; justify-content: center; gap: 15px; margin-top: 5px; }
        button {
            border: 3px solid #000; font-family: inherit; font-weight: 900; font-size: 18px; cursor: pointer; box-shadow: 5px 5px 0 #000; transition: transform 0.1s;
        }
        button:active { transform: translate(3px, 3px); box-shadow: 2px 2px 0 #000; }

        /* ä¿®æ”¹ä¸»æŒ‰é’®æ ·å¼ä¸ºå½•åˆ¶é£æ ¼ */
        #recordBtn {
            background: #00ff00; color: #000; padding: 15px 30px; transform: rotate(2deg); border-radius: 50% 20% 50% 20%;
        }
        /* å½•åˆ¶ä¸­æŒ‰é’®å˜çº¢ */
        #recordBtn.recording {
            background: #ff0000; color: #fff; animation: shake-hard 0.5s infinite;
        }

        @keyframes shake {
            0% { transform: translate(0, 0); } 2% { transform: translate(2px, 2px); } 4% { transform: translate(-2px, 0); } 6% { transform: translate(0, 0); } 100% { transform: translate(0, 0); }
        }
        @keyframes shake-hard {
             0% { transform: translate(0, 0) rotate(2deg); } 25% { transform: translate(3px, 3px) rotate(1deg); } 50% { transform: translate(-3px, 0) rotate(3deg); } 75% { transform: translate(2px, -2px) rotate(2deg); } 100% { transform: translate(0, 0) rotate(2deg); }
        }
    </style>
</head>
<body>

    <div class="window-frame">
        <div class="title-bar">
            <span>V.H.S. TRASH CAM v0.99b</span>
            <span>[X]</span>
        </div>
        
        <div class="marquee-container">
            <marquee scrollamount="10">ğŸ”´ RECORDING MODE ACTIVATED // DO NOT PIRATE TAPES // å½•åƒæ¨¡å¼å·²å¯åŠ¨ // KEEP IT LO-FI // ä¿æŒä½ä¿çœŸ //</marquee>
        </div>

        <div class="viewport-wrapper">
            <div class="sticker s-tape"></div>
            <div id="recIndicator" class="sticker s-rec blinking">â— REC</div>
            <div class="viewport">
                <canvas id="displayCanvas"></canvas>
                <div class="sticker s-eye">ğŸ“¹</div>
            </div>
        </div>

        <div class="controls">
            <button id="recordBtn">START REC</button>
        </div>
    </div>

    <video id="rawVideo" autoplay playsinline muted style="display:none;"></video>

    <script>
        const video = document.getElementById('rawVideo');
        const canvas = document.getElementById('displayCanvas');
        const ctx = canvas.getContext('2d');
        const recordBtn = document.getElementById('recordBtn');
        const recIndicator = document.getElementById('recIndicator');

        // ä¿æŒä½åˆ†è¾¨ç‡ä»¥ç¡®ä¿æ»¤é•œå¤„ç†æµç•…
        const w = 120; 
        const h = 160; 
        canvas.width = w;
        canvas.height = h;

        // æ»¤é•œå‚æ•°ä¸å˜
        const edgeThreshold = 35;
        const popPalette = [[255, 255, 0], [255, 0, 255], [0, 255, 255], [50, 50, 50], [255, 255, 255]];

        let isStreaming = false;
        let animationId;
        
        // å½•åƒç›¸å…³å˜é‡
        let mediaRecorder;
        let recordedChunks = [];
        let isRecording = false;

        function getBrightness(r, g, b) { return 0.299 * r + 0.587 * g + 0.114 * b; }
        function colorDistSq(c1, c2) { return (c1[0]-c2[0])**2 + (c1[1]-c2[1])**2 + (c1[2]-c2[2])**2; }

        async function startCamera() {
            try {
                // é‡è¦ä¿®æ”¹ï¼šåŒæ—¶è¯·æ±‚éŸ³é¢‘å’Œè§†é¢‘
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: "environment", width: 640, height: 480 },
                    audio: true // è¯·æ±‚éº¦å…‹é£æƒé™
                });
                video.srcObject = stream;
                // video.muted = true; // HTMLä¸­å·²ç»è®¾ç½®ï¼ŒåŒé‡ä¿é™©
                
                video.onloadedmetadata = () => {
                    isStreaming = true;
                    renderFrame();
                };
            } catch (err) {
                alert("éœ€è¦éº¦å…‹é£å’Œæ‘„åƒå¤´æƒé™ï¼è¯·ä½¿ç”¨ HTTPSã€‚Error: " + err.name);
            }
        }

        // æ ¸å¿ƒæ¸²æŸ“å¾ªç¯ (ä¿æŒä¸å˜)
        function renderFrame() {
            if (!isStreaming) return;
            ctx.drawImage(video, 0, 0, w, h);
            let srcData = ctx.getImageData(0, 0, w, h).data;
            let outputImgData = ctx.createImageData(w, h);
            let dstData = outputImgData.data;

            for (let y = 1; y < h - 1; y++) {
                for (let x = 1; x < w - 1; x++) {
                    let idx = (y * w + x) * 4;
                    // ... (çœç•¥æ‰ä¸ä¹‹å‰å®Œå…¨ç›¸åŒçš„ Sobel è¾¹ç¼˜æ£€æµ‹å’Œè‰²å½©é‡åŒ–ä»£ç ä»¥èŠ‚çœç¯‡å¹…) ...
                    let idxL = (y * w + (x - 1)) * 4; let idxR = (y * w + (x + 1)) * 4;
                    let idxT = ((y - 1) * w + x) * 4; let idxB = ((y + 1) * w + x) * 4;
                    let briL = getBrightness(srcData[idxL], srcData[idxL+1], srcData[idxL+2]);
                    let briR = getBrightness(srcData[idxR], srcData[idxR+1], srcData[idxR+2]);
                    let briT = getBrightness(srcData[idxT], srcData[idxT+1], srcData[idxT+2]);
                    let briB = getBrightness(srcData[idxB], srcData[idxB+1], srcData[idxB+2]);
                    let edgeStrength = Math.abs(briL - briR) + Math.abs(briT - briB);
                    if (edgeStrength > edgeThreshold) {
                        dstData[idx] = 0; dstData[idx+1] = 0; dstData[idx+2] = 0; dstData[idx+3] = 255;
                    } else {
                        let curR = srcData[idx], curG = srcData[idx+1], curB = srcData[idx+2];
                        let closest = popPalette[0]; let minD = Infinity;
                        for (let col of popPalette) {
                            let d = colorDistSq([curR, curG, curB], col);
                            if (d < minD) { minD = d; closest = col; }
                        }
                        dstData[idx] = closest[0]; dstData[idx+1] = closest[1]; dstData[idx+2] = closest[2]; dstData[idx+3] = 255;
                    }
                }
            }
            ctx.putImageData(outputImgData, 0, 0);
            animationId = requestAnimationFrame(renderFrame);
        }

        // --- å½•åƒæ§åˆ¶é€»è¾‘ ---

        function startRecording() {
            recordedChunks = [];
            // 1. æ•æ‰ Canvas çš„ç”»é¢æµ (è®¾ç½® fps ä¸º 30)
            const canvasStream = canvas.captureStream(30);
            
            // 2. è·å–åŸå§‹è§†é¢‘æµä¸­çš„éŸ³é¢‘è½¨é“ (å¦‚æœæœ‰)
            if (video.srcObject && video.srcObject.getAudioTracks().length > 0) {
                const audioTrack = video.srcObject.getAudioTracks()[0];
                // å°†éŸ³é¢‘è½¨é“æ·»åŠ åˆ° canvas æµä¸­
                canvasStream.addTrack(audioTrack);
            }

            // 3. åˆå§‹åŒ– MediaRecorder
            // å°è¯•ä½¿ç”¨å…¼å®¹æ€§è¾ƒå¥½çš„ WebM æ ¼å¼
            let options = { mimeType: 'video/webm;codecs=vp9' };
            if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                 options = { mimeType: 'video/webm' }; // å›é€€æ–¹æ¡ˆ
            }
            
            try {
                mediaRecorder = new MediaRecorder(canvasStream, options);
            } catch (e) {
                alert('MediaRecorder åˆå§‹åŒ–å¤±è´¥ï¼Œä½ çš„æµè§ˆå™¨å¯èƒ½ä¸æ”¯æŒã€‚');
                return;
            }

            // 4. æ•°æ®æ”¶é›†äº‹ä»¶
            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };

            // 5. åœæ­¢å½•åˆ¶äº‹ä»¶ (å¤„ç†ä¿å­˜)
            mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = 'TRASH-TAPE-' + Date.now() + '.webm';
                document.body.appendChild(a);
                a.click();
                setTimeout(() => {
                    document.body.removeChild(a);
                    window.URL.revokeObjectURL(url);
                    alert("TAPE SAVED! \nå½•åƒå¸¦å·²ä¿å­˜ï¼");
                }, 100);
            };

            // 6. å¼€å§‹å½•åˆ¶
            mediaRecorder.start();
            isRecording = true;
            updateUIState(true);
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            isRecording = false;
            updateUIState(false);
        }

        // æ›´æ–° UI çŠ¶æ€
        function updateUIState(recording) {
            if (recording) {
                recordBtn.innerText = "STOP REC â– ";
                recordBtn.classList.add('recording'); // æ·»åŠ çº¢è‰²éœ‡åŠ¨æ•ˆæœ
                recIndicator.style.display = "block"; // æ˜¾ç¤ºå·¦ä¸Šè§’ REC æŒ‡ç¤ºç¯
            } else {
                recordBtn.innerText = "START REC â–¶";
                recordBtn.classList.remove('recording');
                recIndicator.style.display = "none";
            }
        }

        // æŒ‰é’®ç‚¹å‡»äº‹ä»¶
        recordBtn.addEventListener('click', () => {
            if (!isStreaming) return;
            if (!isRecording) {
                startRecording();
            } else {
                stopRecording();
            }
        });

        // å¯åŠ¨ï¼
        startCamera();

    </script>
</body>
</html>
